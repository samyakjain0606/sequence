{"ast":null,"code":"import{TokenType}from'../models/types';// Create a blank board space\nexport const createBoardSpace=function(){let card=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let isCorner=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return{card,token:TokenType.NONE,isCorner};};// Create a new empty 10x10 board\nexport const createEmptyBoard=()=>{const board=[];for(let i=0;i<10;i++){const row=[];for(let j=0;j<10;j++){row.push(createBoardSpace());}board.push(row);}return board;};// Set the corner spaces (free spaces)\nexport const setCornerSpaces=board=>{const updatedBoard=[...board];// Top-left corner\nupdatedBoard[0][0]=createBoardSpace(null,true);// Top-right corner\nupdatedBoard[0][9]=createBoardSpace(null,true);// Bottom-left corner\nupdatedBoard[9][0]=createBoardSpace(null,true);// Bottom-right corner\nupdatedBoard[9][9]=createBoardSpace(null,true);return updatedBoard;};// Place a token on the board\nexport const placeToken=(board,row,col,tokenType)=>{// Create a deep copy of the board\nconst newBoard=board.map(r=>r.map(space=>({...space,card:space.card?{suit:space.card.suit,rank:space.card.rank,isOneEyedJack:space.card.isOneEyedJack,isTwoEyedJack:space.card.isTwoEyedJack}:null})));// Place the token\nnewBoard[row][col]={...newBoard[row][col],card:newBoard[row][col].card?{suit:newBoard[row][col].card.suit,rank:newBoard[row][col].card.rank,isOneEyedJack:newBoard[row][col].card.isOneEyedJack,isTwoEyedJack:newBoard[row][col].card.isTwoEyedJack}:null,token:tokenType};return newBoard;};// Remove a token from the board\nexport const removeToken=(board,row,col)=>{// Create a deep copy of the board\nconst newBoard=board.map(r=>r.map(space=>({...space,card:space.card?{suit:space.card.suit,rank:space.card.rank,isOneEyedJack:space.card.isOneEyedJack,isTwoEyedJack:space.card.isTwoEyedJack}:null})));// Remove the token\nnewBoard[row][col]={...newBoard[row][col],card:newBoard[row][col].card?{suit:newBoard[row][col].card.suit,rank:newBoard[row][col].card.rank,isOneEyedJack:newBoard[row][col].card.isOneEyedJack,isTwoEyedJack:newBoard[row][col].card.isTwoEyedJack}:null,token:TokenType.NONE};return newBoard;};// Get all positions where a token can be placed\nexport const getValidTokenPlacements=(board,tokenType)=>{const validPositions=[];board.forEach((row,rowIndex)=>{row.forEach((space,colIndex)=>{// Space must be empty and not a corner\nif(space.token===TokenType.NONE&&!space.isCorner){validPositions.push({row:rowIndex,col:colIndex});}});});return validPositions;};// Get all positions where a token can be removed\nexport const getValidTokenRemovals=(board,playerTokenType)=>{const validPositions=[];board.forEach((row,rowIndex)=>{row.forEach((space,colIndex)=>{// Space must have an opponent's token\nif(space.token!==TokenType.NONE&&space.token!==playerTokenType){validPositions.push({row:rowIndex,col:colIndex});}});});return validPositions;};// Check if a position is within board bounds\nexport const isValidPosition=(board,row,col)=>{return row>=0&&row<board.length&&col>=0&&col<board[0].length;};// Get all adjacent positions to a given position\nexport const getAdjacentPositions=(board,row,col)=>{const directions=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];return directions.map(_ref=>{let[dRow,dCol]=_ref;return{row:row+dRow,col:col+dCol};}).filter(pos=>isValidPosition(board,pos.row,pos.col));};// Get all positions in a line from a starting position in a given direction\nexport const getLinePositions=(board,startRow,startCol,directionRow,directionCol,length)=>{const positions=[];for(let i=0;i<length;i++){const row=startRow+i*directionRow;const col=startCol+i*directionCol;if(!isValidPosition(board,row,col)){break;}positions.push({row,col});}return positions;};// Check if a sequence can be formed from a position\nexport const canFormSequence=(board,row,col,tokenType,sequenceLength)=>{const directions=[[0,1],// horizontal\n[1,0],// vertical\n[1,1],// diagonal down-right\n[1,-1]// diagonal down-left\n];return directions.some(_ref2=>{let[dRow,dCol]=_ref2;// Check forward direction\nconst forwardLine=getLinePositions(board,row,col,dRow,dCol,sequenceLength);if(forwardLine.length===sequenceLength&&forwardLine.every(pos=>board[pos.row][pos.col].token===tokenType)){return true;}// Check backward direction\nconst backwardLine=getLinePositions(board,row,col,-dRow,-dCol,sequenceLength);if(backwardLine.length===sequenceLength&&backwardLine.every(pos=>board[pos.row][pos.col].token===tokenType)){return true;}return false;});};const BOARD_LAYOUT=[['♠J','♦6','♦7','♦8','♦9','♦10','♦Q','♦K','♦A','♠2'],['♦5','♥3','♥2','♠2','♠3','♠4','♠5','♠6','♠7','♣A'],['♦4','♥4','♦K','♦A','♣A','♣K','♣Q','♣10','♠8','♣K'],['♦3','♥5','♦Q','♥Q','♥10','♥9','♥8','♣9','♠9','♣Q'],['♦2','♥6','♦10','♥K','♥3','♥2','♥7','♣8','♥10','♣10'],['♠A','♥7','♦9','♥A','♥4','♥5','♥6','♣7','♣Q','♣9'],['♠K','♥8','♦8','♣2','♣3','♣4','♣5','♣6','♠K','♣8'],['♠Q','♥9','♦7','♦6','♦5','♦4','♦3','♦2','♠A','♣7'],['♠10','♥10','♥Q','♥K','♥A','♣2','♣3','♣4','♣5','♣6'],['♣3','♠9','♠8','♠7','♠6','♠5','♠4','♠3','♠2','♠5']];const createCard=cardStr=>{if(cardStr==='')return null;const suitMap={'♠':'spades','♥':'hearts','♦':'diamonds','♣':'clubs'};const suit=suitMap[cardStr[0]];const rank=cardStr.slice(1);// One-eyed jacks are spades and hearts\nconst isOneEyedJack=rank==='J'&&(suit==='spades'||suit==='hearts');// Two-eyed jacks are diamonds and clubs\nconst isTwoEyedJack=rank==='J'&&(suit==='diamonds'||suit==='clubs');return{suit,rank,isOneEyedJack,isTwoEyedJack};};// Initialize the game board\nexport const initializeBoard=()=>{const board=[];for(let row=0;row<BOARD_LAYOUT.length;row++){board[row]=[];for(let col=0;col<BOARD_LAYOUT[row].length;col++){const isCorner=(row===0||row===9)&&(col===0||col===9);board[row][col]={card:isCorner?null:createCard(BOARD_LAYOUT[row][col]),token:TokenType.NONE,isCorner};}}return board;};// Check if a sequence of 5 tokens exists on the board\nexport const checkForSequence=(board,tokenType)=>{// Check horizontal sequences\nfor(let i=0;i<10;i++){for(let j=0;j<=5;j++){if(board[i][j].token===tokenType&&board[i][j+1].token===tokenType&&board[i][j+2].token===tokenType&&board[i][j+3].token===tokenType&&board[i][j+4].token===tokenType){return true;}}}// Check vertical sequences\nfor(let i=0;i<=5;i++){for(let j=0;j<10;j++){if(board[i][j].token===tokenType&&board[i+1][j].token===tokenType&&board[i+2][j].token===tokenType&&board[i+3][j].token===tokenType&&board[i+4][j].token===tokenType){return true;}}}// Check diagonal sequences (top-left to bottom-right)\nfor(let i=0;i<=5;i++){for(let j=0;j<=5;j++){if(board[i][j].token===tokenType&&board[i+1][j+1].token===tokenType&&board[i+2][j+2].token===tokenType&&board[i+3][j+3].token===tokenType&&board[i+4][j+4].token===tokenType){return true;}}}// Check diagonal sequences (top-right to bottom-left)\nfor(let i=0;i<=5;i++){for(let j=4;j<10;j++){if(board[i][j].token===tokenType&&board[i+1][j-1].token===tokenType&&board[i+2][j-2].token===tokenType&&board[i+3][j-3].token===tokenType&&board[i+4][j-4].token===tokenType){return true;}}}return false;};// Get all positions of a specific card on the board\nexport const getCardPositions=(board,card)=>{const positions=[];board.forEach((row,rowIndex)=>{row.forEach((space,colIndex)=>{if(space.card&&space.card.suit===card.suit&&space.card.rank===card.rank){positions.push({row:rowIndex,col:colIndex});}});});return positions;};","map":{"version":3,"names":["TokenType","createBoardSpace","card","arguments","length","undefined","isCorner","token","NONE","createEmptyBoard","board","i","row","j","push","setCornerSpaces","updatedBoard","placeToken","col","tokenType","newBoard","map","r","space","suit","rank","isOneEyedJack","isTwoEyedJack","removeToken","getValidTokenPlacements","validPositions","forEach","rowIndex","colIndex","getValidTokenRemovals","playerTokenType","isValidPosition","getAdjacentPositions","directions","_ref","dRow","dCol","filter","pos","getLinePositions","startRow","startCol","directionRow","directionCol","positions","canFormSequence","sequenceLength","some","_ref2","forwardLine","every","backwardLine","BOARD_LAYOUT","createCard","cardStr","suitMap","slice","initializeBoard","checkForSequence","getCardPositions"],"sources":["/Users/samjain/seq/sequence/src/utils/boardUtils.ts"],"sourcesContent":["import { Board, BoardSpace, Card, Rank, Suit, TokenType, Position } from '../models/types';\n\n// Create a blank board space\nexport const createBoardSpace = (card: Card | null = null, isCorner: boolean = false): BoardSpace => {\n  return {\n    card,\n    token: TokenType.NONE,\n    isCorner,\n  };\n};\n\n// Create a new empty 10x10 board\nexport const createEmptyBoard = (): Board => {\n  const board: Board = [];\n  for (let i = 0; i < 10; i++) {\n    const row: BoardSpace[] = [];\n    for (let j = 0; j < 10; j++) {\n      row.push(createBoardSpace());\n    }\n    board.push(row);\n  }\n  return board;\n};\n\n// Set the corner spaces (free spaces)\nexport const setCornerSpaces = (board: Board): Board => {\n  const updatedBoard = [...board];\n  \n  // Top-left corner\n  updatedBoard[0][0] = createBoardSpace(null, true);\n  \n  // Top-right corner\n  updatedBoard[0][9] = createBoardSpace(null, true);\n  \n  // Bottom-left corner\n  updatedBoard[9][0] = createBoardSpace(null, true);\n  \n  // Bottom-right corner\n  updatedBoard[9][9] = createBoardSpace(null, true);\n  \n  return updatedBoard;\n};\n\n// Place a token on the board\nexport const placeToken = (board: Board, row: number, col: number, tokenType: TokenType): Board => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n  \n  // Place the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card!.suit,\n      rank: newBoard[row][col].card!.rank,\n      isOneEyedJack: newBoard[row][col].card!.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card!.isTwoEyedJack\n    } : null,\n    token: tokenType,\n  };\n  \n  return newBoard;\n};\n\n// Remove a token from the board\nexport const removeToken = (board: Board, row: number, col: number): Board => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n  \n  // Remove the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card!.suit,\n      rank: newBoard[row][col].card!.rank,\n      isOneEyedJack: newBoard[row][col].card!.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card!.isTwoEyedJack\n    } : null,\n    token: TokenType.NONE,\n  };\n  \n  return newBoard;\n};\n\n// Get all positions where a token can be placed\nexport const getValidTokenPlacements = (board: Board, tokenType: TokenType): Position[] => {\n  const validPositions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must be empty and not a corner\n      if (space.token === TokenType.NONE && !space.isCorner) {\n        validPositions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return validPositions;\n};\n\n// Get all positions where a token can be removed\nexport const getValidTokenRemovals = (board: Board, playerTokenType: TokenType): Position[] => {\n  const validPositions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must have an opponent's token\n      if (space.token !== TokenType.NONE && space.token !== playerTokenType) {\n        validPositions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return validPositions;\n};\n\n// Check if a position is within board bounds\nexport const isValidPosition = (board: Board, row: number, col: number): boolean => {\n  return row >= 0 && row < board.length && col >= 0 && col < board[0].length;\n};\n\n// Get all adjacent positions to a given position\nexport const getAdjacentPositions = (board: Board, row: number, col: number): Position[] => {\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1],\n    [0, -1],           [0, 1],\n    [1, -1],  [1, 0],  [1, 1]\n  ];\n  \n  return directions\n    .map(([dRow, dCol]) => ({\n      row: row + dRow,\n      col: col + dCol\n    }))\n    .filter(pos => isValidPosition(board, pos.row, pos.col));\n};\n\n// Get all positions in a line from a starting position in a given direction\nexport const getLinePositions = (\n  board: Board,\n  startRow: number,\n  startCol: number,\n  directionRow: number,\n  directionCol: number,\n  length: number\n): Position[] => {\n  const positions: Position[] = [];\n  \n  for (let i = 0; i < length; i++) {\n    const row = startRow + i * directionRow;\n    const col = startCol + i * directionCol;\n    \n    if (!isValidPosition(board, row, col)) {\n      break;\n    }\n    \n    positions.push({ row, col });\n  }\n  \n  return positions;\n};\n\n// Check if a sequence can be formed from a position\nexport const canFormSequence = (\n  board: Board,\n  row: number,\n  col: number,\n  tokenType: TokenType,\n  sequenceLength: number\n): boolean => {\n  const directions = [\n    [0, 1],   // horizontal\n    [1, 0],   // vertical\n    [1, 1],   // diagonal down-right\n    [1, -1]   // diagonal down-left\n  ];\n  \n  return directions.some(([dRow, dCol]) => {\n    // Check forward direction\n    const forwardLine = getLinePositions(board, row, col, dRow, dCol, sequenceLength);\n    if (forwardLine.length === sequenceLength &&\n        forwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n    \n    // Check backward direction\n    const backwardLine = getLinePositions(board, row, col, -dRow, -dCol, sequenceLength);\n    if (backwardLine.length === sequenceLength &&\n        backwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n    \n    return false;\n  });\n};\n\nconst BOARD_LAYOUT = [\n  ['♠J', '♦6', '♦7', '♦8', '♦9', '♦10', '♦Q', '♦K', '♦A', '♠2'],\n  ['♦5', '♥3', '♥2', '♠2', '♠3', '♠4', '♠5', '♠6', '♠7', '♣A'],\n  ['♦4', '♥4', '♦K', '♦A', '♣A', '♣K', '♣Q', '♣10', '♠8', '♣K'],\n  ['♦3', '♥5', '♦Q', '♥Q', '♥10', '♥9', '♥8', '♣9', '♠9', '♣Q'],\n  ['♦2', '♥6', '♦10', '♥K', '♥3', '♥2', '♥7', '♣8', '♥10', '♣10'],\n  ['♠A', '♥7', '♦9', '♥A', '♥4', '♥5', '♥6', '♣7', '♣Q', '♣9'],\n  ['♠K', '♥8', '♦8', '♣2', '♣3', '♣4', '♣5', '♣6', '♠K', '♣8'],\n  ['♠Q', '♥9', '♦7', '♦6', '♦5', '♦4', '♦3', '♦2', '♠A', '♣7'],\n  ['♠10', '♥10', '♥Q', '♥K', '♥A', '♣2', '♣3', '♣4', '♣5', '♣6'],\n  ['♣3', '♠9', '♠8', '♠7', '♠6', '♠5', '♠4', '♠3', '♠2', '♠5']\n];\n\nconst createCard = (cardStr: string): Card | null => {\n  if (cardStr === '') return null;\n  \n  const suitMap: { [key: string]: Suit } = {\n    '♠': 'spades',\n    '♥': 'hearts',\n    '♦': 'diamonds',\n    '♣': 'clubs'\n  };\n\n  const suit = suitMap[cardStr[0]];\n  const rank = cardStr.slice(1) as Rank;\n\n  // One-eyed jacks are spades and hearts\n  const isOneEyedJack = rank === 'J' && (suit === 'spades' || suit === 'hearts');\n  // Two-eyed jacks are diamonds and clubs\n  const isTwoEyedJack = rank === 'J' && (suit === 'diamonds' || suit === 'clubs');\n\n  return { suit, rank, isOneEyedJack, isTwoEyedJack };\n};\n\n// Initialize the game board\nexport const initializeBoard = (): Board => {\n  const board: Board = [];\n  \n  for (let row = 0; row < BOARD_LAYOUT.length; row++) {\n    board[row] = [];\n    for (let col = 0; col < BOARD_LAYOUT[row].length; col++) {\n      const isCorner = (row === 0 || row === 9) && (col === 0 || col === 9);\n      board[row][col] = {\n        card: isCorner ? null : createCard(BOARD_LAYOUT[row][col]),\n        token: TokenType.NONE,\n        isCorner\n      };\n    }\n  }\n  \n  return board;\n};\n\n// Check if a sequence of 5 tokens exists on the board\nexport const checkForSequence = (board: Board, tokenType: TokenType): boolean => {\n  // Check horizontal sequences\n  for (let i = 0; i < 10; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i][j+1].token === tokenType &&\n          board[i][j+2].token === tokenType &&\n          board[i][j+3].token === tokenType &&\n          board[i][j+4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check vertical sequences\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j < 10; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j].token === tokenType &&\n          board[i+2][j].token === tokenType &&\n          board[i+3][j].token === tokenType &&\n          board[i+4][j].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check diagonal sequences (top-left to bottom-right)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j+1].token === tokenType &&\n          board[i+2][j+2].token === tokenType &&\n          board[i+3][j+3].token === tokenType &&\n          board[i+4][j+4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check diagonal sequences (top-right to bottom-left)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 4; j < 10; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j-1].token === tokenType &&\n          board[i+2][j-2].token === tokenType &&\n          board[i+3][j-3].token === tokenType &&\n          board[i+4][j-4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Get all positions of a specific card on the board\nexport const getCardPositions = (board: Board, card: Card): Position[] => {\n  const positions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      if (space.card && \n          space.card.suit === card.suit && \n          space.card.rank === card.rank) {\n        positions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return positions;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}