{"ast":null,"code":"import { TokenType } from '../models/types';\n\n// Create a blank board space\nexport const createBoardSpace = (card = null, isCorner = false) => {\n  return {\n    card,\n    token: TokenType.NONE,\n    isCorner\n  };\n};\n\n// Create a new empty 10x10 board\nexport const createEmptyBoard = () => {\n  const board = [];\n  for (let i = 0; i < 10; i++) {\n    const row = [];\n    for (let j = 0; j < 10; j++) {\n      row.push(createBoardSpace());\n    }\n    board.push(row);\n  }\n  return board;\n};\n\n// Set the corner spaces (free spaces)\nexport const setCornerSpaces = board => {\n  const updatedBoard = [...board];\n\n  // Top-left corner\n  updatedBoard[0][0] = createBoardSpace(null, true);\n\n  // Top-right corner\n  updatedBoard[0][9] = createBoardSpace(null, true);\n\n  // Bottom-left corner\n  updatedBoard[9][0] = createBoardSpace(null, true);\n\n  // Bottom-right corner\n  updatedBoard[9][9] = createBoardSpace(null, true);\n  return updatedBoard;\n};\n\n// Place a token on the board\nexport const placeToken = (board, row, col, tokenType) => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n\n  // Place the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card.suit,\n      rank: newBoard[row][col].card.rank,\n      isOneEyedJack: newBoard[row][col].card.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card.isTwoEyedJack\n    } : null,\n    token: tokenType\n  };\n  return newBoard;\n};\n\n// Remove a token from the board\nexport const removeToken = (board, row, col) => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n\n  // Remove the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card.suit,\n      rank: newBoard[row][col].card.rank,\n      isOneEyedJack: newBoard[row][col].card.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card.isTwoEyedJack\n    } : null,\n    token: TokenType.NONE\n  };\n  return newBoard;\n};\n\n// Get all positions where a token can be placed\nexport const getValidTokenPlacements = (board, tokenType) => {\n  const validPositions = [];\n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must be empty and not a corner\n      if (space.token === TokenType.NONE && !space.isCorner) {\n        validPositions.push({\n          row: rowIndex,\n          col: colIndex\n        });\n      }\n    });\n  });\n  return validPositions;\n};\n\n// Get all positions where a token can be removed\nexport const getValidTokenRemovals = (board, playerTokenType) => {\n  const validPositions = [];\n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must have an opponent's token\n      if (space.token !== TokenType.NONE && space.token !== playerTokenType) {\n        validPositions.push({\n          row: rowIndex,\n          col: colIndex\n        });\n      }\n    });\n  });\n  return validPositions;\n};\n\n// Check if a position is within board bounds\nexport const isValidPosition = (board, row, col) => {\n  return row >= 0 && row < board.length && col >= 0 && col < board[0].length;\n};\n\n// Get all adjacent positions to a given position\nexport const getAdjacentPositions = (board, row, col) => {\n  const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n  return directions.map(([dRow, dCol]) => ({\n    row: row + dRow,\n    col: col + dCol\n  })).filter(pos => isValidPosition(board, pos.row, pos.col));\n};\n\n// Get all positions in a line from a starting position in a given direction\nexport const getLinePositions = (board, startRow, startCol, directionRow, directionCol, length) => {\n  const positions = [];\n  for (let i = 0; i < length; i++) {\n    const row = startRow + i * directionRow;\n    const col = startCol + i * directionCol;\n    if (!isValidPosition(board, row, col)) {\n      break;\n    }\n    positions.push({\n      row,\n      col\n    });\n  }\n  return positions;\n};\n\n// Check if a sequence can be formed from a position\nexport const canFormSequence = (board, row, col, tokenType, sequenceLength) => {\n  const directions = [[0, 1],\n  // horizontal\n  [1, 0],\n  // vertical\n  [1, 1],\n  // diagonal down-right\n  [1, -1] // diagonal down-left\n  ];\n  return directions.some(([dRow, dCol]) => {\n    // Check forward direction\n    const forwardLine = getLinePositions(board, row, col, dRow, dCol, sequenceLength);\n    if (forwardLine.length === sequenceLength && forwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n\n    // Check backward direction\n    const backwardLine = getLinePositions(board, row, col, -dRow, -dCol, sequenceLength);\n    if (backwardLine.length === sequenceLength && backwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n    return false;\n  });\n};\nconst BOARD_LAYOUT = [['♠J', '♦6', '♦7', '♦8', '♦9', '♦10', '♦Q', '♦K', '♦A', '♠2'], ['♦5', '♥3', '♥2', '♠2', '♠3', '♠4', '♠5', '♠6', '♠7', '♣A'], ['♦4', '♥4', '♦K', '♦A', '♣A', '♣K', '♣Q', '♣10', '♠8', '♣K'], ['♦3', '♥5', '♦Q', '♥Q', '♥10', '♥9', '♥8', '♣9', '♠9', '♣Q'], ['♦2', '♥6', '♦10', '♥K', '♥3', '♥2', '♥7', '♣8', '♥10', '♣10'], ['♠A', '♥7', '♦9', '♥A', '♥4', '♥5', '♥6', '♣7', '♣Q', '♣9'], ['♠K', '♥8', '♦8', '♣2', '♣3', '♣4', '♣5', '♣6', '♠K', '♣8'], ['♠Q', '♥9', '♦7', '♦6', '♦5', '♦4', '♦3', '♦2', '♠A', '♣7'], ['♠10', '♥10', '♥Q', '♥K', '♥A', '♣2', '♣3', '♣4', '♣5', '♣6'], ['♣3', '♠9', '♠8', '♠7', '♠6', '♠5', '♠4', '♠3', '♠2', '♠5']];\nconst createCard = cardStr => {\n  if (cardStr === '') return null;\n  const suitMap = {\n    '♠': 'spades',\n    '♥': 'hearts',\n    '♦': 'diamonds',\n    '♣': 'clubs'\n  };\n  const suit = suitMap[cardStr[0]];\n  const rank = cardStr.slice(1);\n\n  // One-eyed jacks are spades and hearts\n  const isOneEyedJack = rank === 'J' && (suit === 'spades' || suit === 'hearts');\n  // Two-eyed jacks are diamonds and clubs\n  const isTwoEyedJack = rank === 'J' && (suit === 'diamonds' || suit === 'clubs');\n  return {\n    suit,\n    rank,\n    isOneEyedJack,\n    isTwoEyedJack\n  };\n};\n\n// Initialize the game board\nexport const initializeBoard = () => {\n  const board = [];\n  for (let row = 0; row < BOARD_LAYOUT.length; row++) {\n    board[row] = [];\n    for (let col = 0; col < BOARD_LAYOUT[row].length; col++) {\n      const isCorner = (row === 0 || row === 9) && (col === 0 || col === 9);\n      board[row][col] = {\n        card: isCorner ? null : createCard(BOARD_LAYOUT[row][col]),\n        token: TokenType.NONE,\n        isCorner\n      };\n    }\n  }\n  return board;\n};\n\n// Check if a sequence of 5 tokens exists on the board\nexport const checkForSequence = (board, tokenType) => {\n  // Check horizontal sequences\n  for (let i = 0; i < 10; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType && board[i][j + 1].token === tokenType && board[i][j + 2].token === tokenType && board[i][j + 3].token === tokenType && board[i][j + 4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n\n  // Check vertical sequences\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j < 10; j++) {\n      if (board[i][j].token === tokenType && board[i + 1][j].token === tokenType && board[i + 2][j].token === tokenType && board[i + 3][j].token === tokenType && board[i + 4][j].token === tokenType) {\n        return true;\n      }\n    }\n  }\n\n  // Check diagonal sequences (top-left to bottom-right)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType && board[i + 1][j + 1].token === tokenType && board[i + 2][j + 2].token === tokenType && board[i + 3][j + 3].token === tokenType && board[i + 4][j + 4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n\n  // Check diagonal sequences (top-right to bottom-left)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 4; j < 10; j++) {\n      if (board[i][j].token === tokenType && board[i + 1][j - 1].token === tokenType && board[i + 2][j - 2].token === tokenType && board[i + 3][j - 3].token === tokenType && board[i + 4][j - 4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Get all positions of a specific card on the board\nexport const getCardPositions = (board, card) => {\n  const positions = [];\n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      if (space.card && space.card.suit === card.suit && space.card.rank === card.rank) {\n        positions.push({\n          row: rowIndex,\n          col: colIndex\n        });\n      }\n    });\n  });\n  return positions;\n};","map":{"version":3,"names":["TokenType","createBoardSpace","card","isCorner","token","NONE","createEmptyBoard","board","i","row","j","push","setCornerSpaces","updatedBoard","placeToken","col","tokenType","newBoard","map","r","space","suit","rank","isOneEyedJack","isTwoEyedJack","removeToken","getValidTokenPlacements","validPositions","forEach","rowIndex","colIndex","getValidTokenRemovals","playerTokenType","isValidPosition","length","getAdjacentPositions","directions","dRow","dCol","filter","pos","getLinePositions","startRow","startCol","directionRow","directionCol","positions","canFormSequence","sequenceLength","some","forwardLine","every","backwardLine","BOARD_LAYOUT","createCard","cardStr","suitMap","slice","initializeBoard","checkForSequence","getCardPositions"],"sources":["/Users/samjain/seq/sequence/src/utils/boardUtils.ts"],"sourcesContent":["import { Board, BoardSpace, Card, Rank, Suit, TokenType, Position } from '../models/types';\n\n// Create a blank board space\nexport const createBoardSpace = (card: Card | null = null, isCorner: boolean = false): BoardSpace => {\n  return {\n    card,\n    token: TokenType.NONE,\n    isCorner,\n  };\n};\n\n// Create a new empty 10x10 board\nexport const createEmptyBoard = (): Board => {\n  const board: Board = [];\n  for (let i = 0; i < 10; i++) {\n    const row: BoardSpace[] = [];\n    for (let j = 0; j < 10; j++) {\n      row.push(createBoardSpace());\n    }\n    board.push(row);\n  }\n  return board;\n};\n\n// Set the corner spaces (free spaces)\nexport const setCornerSpaces = (board: Board): Board => {\n  const updatedBoard = [...board];\n  \n  // Top-left corner\n  updatedBoard[0][0] = createBoardSpace(null, true);\n  \n  // Top-right corner\n  updatedBoard[0][9] = createBoardSpace(null, true);\n  \n  // Bottom-left corner\n  updatedBoard[9][0] = createBoardSpace(null, true);\n  \n  // Bottom-right corner\n  updatedBoard[9][9] = createBoardSpace(null, true);\n  \n  return updatedBoard;\n};\n\n// Place a token on the board\nexport const placeToken = (board: Board, row: number, col: number, tokenType: TokenType): Board => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n  \n  // Place the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card!.suit,\n      rank: newBoard[row][col].card!.rank,\n      isOneEyedJack: newBoard[row][col].card!.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card!.isTwoEyedJack\n    } : null,\n    token: tokenType,\n  };\n  \n  return newBoard;\n};\n\n// Remove a token from the board\nexport const removeToken = (board: Board, row: number, col: number): Board => {\n  // Create a deep copy of the board\n  const newBoard = board.map(r => r.map(space => ({\n    ...space,\n    card: space.card ? {\n      suit: space.card.suit,\n      rank: space.card.rank,\n      isOneEyedJack: space.card.isOneEyedJack,\n      isTwoEyedJack: space.card.isTwoEyedJack\n    } : null\n  })));\n  \n  // Remove the token\n  newBoard[row][col] = {\n    ...newBoard[row][col],\n    card: newBoard[row][col].card ? {\n      suit: newBoard[row][col].card!.suit,\n      rank: newBoard[row][col].card!.rank,\n      isOneEyedJack: newBoard[row][col].card!.isOneEyedJack,\n      isTwoEyedJack: newBoard[row][col].card!.isTwoEyedJack\n    } : null,\n    token: TokenType.NONE,\n  };\n  \n  return newBoard;\n};\n\n// Get all positions where a token can be placed\nexport const getValidTokenPlacements = (board: Board, tokenType: TokenType): Position[] => {\n  const validPositions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must be empty and not a corner\n      if (space.token === TokenType.NONE && !space.isCorner) {\n        validPositions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return validPositions;\n};\n\n// Get all positions where a token can be removed\nexport const getValidTokenRemovals = (board: Board, playerTokenType: TokenType): Position[] => {\n  const validPositions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      // Space must have an opponent's token\n      if (space.token !== TokenType.NONE && space.token !== playerTokenType) {\n        validPositions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return validPositions;\n};\n\n// Check if a position is within board bounds\nexport const isValidPosition = (board: Board, row: number, col: number): boolean => {\n  return row >= 0 && row < board.length && col >= 0 && col < board[0].length;\n};\n\n// Get all adjacent positions to a given position\nexport const getAdjacentPositions = (board: Board, row: number, col: number): Position[] => {\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1],\n    [0, -1],           [0, 1],\n    [1, -1],  [1, 0],  [1, 1]\n  ];\n  \n  return directions\n    .map(([dRow, dCol]) => ({\n      row: row + dRow,\n      col: col + dCol\n    }))\n    .filter(pos => isValidPosition(board, pos.row, pos.col));\n};\n\n// Get all positions in a line from a starting position in a given direction\nexport const getLinePositions = (\n  board: Board,\n  startRow: number,\n  startCol: number,\n  directionRow: number,\n  directionCol: number,\n  length: number\n): Position[] => {\n  const positions: Position[] = [];\n  \n  for (let i = 0; i < length; i++) {\n    const row = startRow + i * directionRow;\n    const col = startCol + i * directionCol;\n    \n    if (!isValidPosition(board, row, col)) {\n      break;\n    }\n    \n    positions.push({ row, col });\n  }\n  \n  return positions;\n};\n\n// Check if a sequence can be formed from a position\nexport const canFormSequence = (\n  board: Board,\n  row: number,\n  col: number,\n  tokenType: TokenType,\n  sequenceLength: number\n): boolean => {\n  const directions = [\n    [0, 1],   // horizontal\n    [1, 0],   // vertical\n    [1, 1],   // diagonal down-right\n    [1, -1]   // diagonal down-left\n  ];\n  \n  return directions.some(([dRow, dCol]) => {\n    // Check forward direction\n    const forwardLine = getLinePositions(board, row, col, dRow, dCol, sequenceLength);\n    if (forwardLine.length === sequenceLength &&\n        forwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n    \n    // Check backward direction\n    const backwardLine = getLinePositions(board, row, col, -dRow, -dCol, sequenceLength);\n    if (backwardLine.length === sequenceLength &&\n        backwardLine.every(pos => board[pos.row][pos.col].token === tokenType)) {\n      return true;\n    }\n    \n    return false;\n  });\n};\n\nconst BOARD_LAYOUT = [\n  ['♠J', '♦6', '♦7', '♦8', '♦9', '♦10', '♦Q', '♦K', '♦A', '♠2'],\n  ['♦5', '♥3', '♥2', '♠2', '♠3', '♠4', '♠5', '♠6', '♠7', '♣A'],\n  ['♦4', '♥4', '♦K', '♦A', '♣A', '♣K', '♣Q', '♣10', '♠8', '♣K'],\n  ['♦3', '♥5', '♦Q', '♥Q', '♥10', '♥9', '♥8', '♣9', '♠9', '♣Q'],\n  ['♦2', '♥6', '♦10', '♥K', '♥3', '♥2', '♥7', '♣8', '♥10', '♣10'],\n  ['♠A', '♥7', '♦9', '♥A', '♥4', '♥5', '♥6', '♣7', '♣Q', '♣9'],\n  ['♠K', '♥8', '♦8', '♣2', '♣3', '♣4', '♣5', '♣6', '♠K', '♣8'],\n  ['♠Q', '♥9', '♦7', '♦6', '♦5', '♦4', '♦3', '♦2', '♠A', '♣7'],\n  ['♠10', '♥10', '♥Q', '♥K', '♥A', '♣2', '♣3', '♣4', '♣5', '♣6'],\n  ['♣3', '♠9', '♠8', '♠7', '♠6', '♠5', '♠4', '♠3', '♠2', '♠5']\n];\n\nconst createCard = (cardStr: string): Card | null => {\n  if (cardStr === '') return null;\n  \n  const suitMap: { [key: string]: Suit } = {\n    '♠': 'spades',\n    '♥': 'hearts',\n    '♦': 'diamonds',\n    '♣': 'clubs'\n  };\n\n  const suit = suitMap[cardStr[0]];\n  const rank = cardStr.slice(1) as Rank;\n\n  // One-eyed jacks are spades and hearts\n  const isOneEyedJack = rank === 'J' && (suit === 'spades' || suit === 'hearts');\n  // Two-eyed jacks are diamonds and clubs\n  const isTwoEyedJack = rank === 'J' && (suit === 'diamonds' || suit === 'clubs');\n\n  return { suit, rank, isOneEyedJack, isTwoEyedJack };\n};\n\n// Initialize the game board\nexport const initializeBoard = (): Board => {\n  const board: Board = [];\n  \n  for (let row = 0; row < BOARD_LAYOUT.length; row++) {\n    board[row] = [];\n    for (let col = 0; col < BOARD_LAYOUT[row].length; col++) {\n      const isCorner = (row === 0 || row === 9) && (col === 0 || col === 9);\n      board[row][col] = {\n        card: isCorner ? null : createCard(BOARD_LAYOUT[row][col]),\n        token: TokenType.NONE,\n        isCorner\n      };\n    }\n  }\n  \n  return board;\n};\n\n// Check if a sequence of 5 tokens exists on the board\nexport const checkForSequence = (board: Board, tokenType: TokenType): boolean => {\n  // Check horizontal sequences\n  for (let i = 0; i < 10; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i][j+1].token === tokenType &&\n          board[i][j+2].token === tokenType &&\n          board[i][j+3].token === tokenType &&\n          board[i][j+4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check vertical sequences\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j < 10; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j].token === tokenType &&\n          board[i+2][j].token === tokenType &&\n          board[i+3][j].token === tokenType &&\n          board[i+4][j].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check diagonal sequences (top-left to bottom-right)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 0; j <= 5; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j+1].token === tokenType &&\n          board[i+2][j+2].token === tokenType &&\n          board[i+3][j+3].token === tokenType &&\n          board[i+4][j+4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  // Check diagonal sequences (top-right to bottom-left)\n  for (let i = 0; i <= 5; i++) {\n    for (let j = 4; j < 10; j++) {\n      if (board[i][j].token === tokenType &&\n          board[i+1][j-1].token === tokenType &&\n          board[i+2][j-2].token === tokenType &&\n          board[i+3][j-3].token === tokenType &&\n          board[i+4][j-4].token === tokenType) {\n        return true;\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Get all positions of a specific card on the board\nexport const getCardPositions = (board: Board, card: Card): Position[] => {\n  const positions: Position[] = [];\n  \n  board.forEach((row, rowIndex) => {\n    row.forEach((space, colIndex) => {\n      if (space.card && \n          space.card.suit === card.suit && \n          space.card.rank === card.rank) {\n        positions.push({ row: rowIndex, col: colIndex });\n      }\n    });\n  });\n  \n  return positions;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}